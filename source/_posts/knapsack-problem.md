---
title: backpack-problem
date: 2019-01-28 10:40:27
tags:
- algorithm
---

# 动态规划

## 01背包问题

### 题目
有`N`件物品和一个容量为`V`的背包。第i件物品的费用是`c[i]`，价值是`w[i]`。求解将哪些物品装入背包可使价值总和最大。

### 基本思路

每种物品仅有一件，可以选择放或不放

用子问题定义状态：即`f[i][v]`表示前i件物品恰放入一个容量为v的背包可以获得的最大价值。则其状态转移方程便是

`f[i][v] = max{f[i-1][v], f[i-1][v-c[i]]+w[i]}`

```c++
for i = 1..N
  for v = 0..V
    f[i][v] = max{f[i-1][v], f[i-1][v-c[i]] + w[i]};
```

"将前 i 件物品放入容量为 V 的背包中"这个子问题，若只考虑第 i 件物品的策略（放或不放），那么就可以转化为一个只牵扯前 i-1 件物品的问题。

- 如果不放第i件物品，那么问题就转化为“前i-1件物品放入容量为v的背包中”，价值为`f[i-1][v]`
- 如果放第i件物品，那么问题就转化为“前i-1件物品放入剩下的容量为`v-c[i]`的背包中”，此时能获得的最大价值就是`f[i-1][v-c[i]]`再加上通过放入第i件物品获得的价值`w[i]`

### 优化空间复杂度

使用一维数组把空间复杂度 从 `O(VN)` 优化到 `O(V)`

第i次循环结束后`f[v]`中表示的就是我们定义的状态`f[i][v]`

```c++
for i = 1..N
  for v = V..0
    f[v] = max{f[v], f[v-c[i]] + w[i]};
```
### 初始化的细节问题
背包合法的解

初始化的f数组事实上就是在没有任何物品可以放入背包时的合法状态

- 恰好装满背包
在初始化时除了`f[0]`为`0`其它`f[1..V]`均设为负无穷
- 没有要求必须把背包装满
将`f[0..V]`全部设为`0`

### 一个常数优化

由于只需要最后一个背包`f[v]`的值，倒推前一个背包，其实只要知道`f[v-w[n]]`即可, 减出最后一个物品的 `w`。以此类推，对以第`j`个背包，其实只需要知道到`f[v-sum{w[j..n]}]`即可

```c++
for i = 1..N
  bound = max{V - sum{w[i..n]}, c[i]};
  for v = V..bound
    f[v] = max{f[v], f[v-c[i]] + w[i]};
```

## 完全背包问题

### 题目

有`N`种物品和一个容量为`V`的背包，每种物品都有无限件可用。第`i`种物品的费用是`c[i]`，价值是`w[i]`。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大

### 基本思路

有取0件、取1件、取2件...取 k 件等很多种

`f[i][v] = max{f[i - 1][v - k*c[i]] + k*w[i] | 0 <= k*c[i] <= v}`

```c++
for i = 1..N
  for v = 0..V
    f[v] = max{f[v], f[v - cost] + weight}
```
### 一个简单有效的优化
- 若两件物品i、j满足c[i]=w[j]，则将物品j去掉，不用考虑
- 将价值小费用高得j换成物美价廉的i

### 转化为01背包问题
- 最简单的想法是，考虑到第i种物品最多选V/c[i]件，于是可以把第i种物品转化为V/c[i]件费用及价值均不变的物品，然后求解这个01背包问题
- 更高效的转化方法是：把第i种物品拆成费用为`c[i]*2^k`、价值为`w[i]*2^k`的若干件物品，其中`k`满足`c[i]*2^k<=V`

## 多重背包问题

### 题目
有N种物品和一个容量为V的背包。第i种物品最多有n[i]件可用，每件费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。

### 基本思路

有取0件、取1件、取2件...取 n[i] 件等很多种

`f[i][v] = max{f[i - 1][v - k*c[i]] + k*w[i] | 0 <= k*c[i] <= n[i]}`


## 参考

> [背包问题](https://www.kancloud.cn/kancloud/pack/70125)
